> 主要参考学习资料：B站【普中官方】51单片机手把手教学视频
>
>开发资料下载链接：http://www.prechin.cn/gongsixinwen/208.html
>
> 前置知识：C语言
>
> 单片机套装：普中STC51单片机开发板A4标准版套餐7

@[TOC](目录)
# 通信的基本概念

## 串行通信与并行通信

### 串行通信

使用一条数据线，8位顺次传送，适用于远距离传输，数据处理较复杂。

### 并行通信

使用多条数据线，8位同时传送，数据处理简单，传输速度快，成本高。

## 异步通信与同步通信

### 异步通信

发送设备和接收设备使用各自的时钟，要求两者时钟尽量但不严格一致。

相邻字符帧间隙任意，相邻位间隙相等。

![](https://i-blog.csdnimg.cn/direct/031035365c49463989be72856a083d39.png)

### 同步通信

发送设备时钟控制接收设备使两者时钟同步。

相邻字符帧不留间隙，相邻位间隙相等。

**外同步**：两条线分别传输数据信号和时钟信号。

**自同步**：一条线传输数据和时钟的叠加信号。0先低后高，1先高后低。

![](https://i-blog.csdnimg.cn/direct/e3f9ffe2fc554f9391995e133fb0717d.png)

## 单工、半双工与全双工通信

**单工通信（广播）**：数据只按一个方向传输，不能反向传输。

**半双工通信（对讲机）**：数据可以按两个方向传输，但只能分时进行。

**全双工通信（电话）**：数据可以同时按两个方向传输。

## 通信速率

**比特率（bps）**：每秒钟传输二进制代码的位数。

**波特率（Baud）**：每秒钟传输的码元数。

**码元**：承载信息量的基本信号单位。通常一个码元表示两种状态0和1，此时波特率=比特率。

# 51单片机串口介绍

## 串口通信简介

**串口通信**指外设和计算机之间以数据信号线和地线按照位进行数据传输的通信方式。

### 接口标准

**串口**（串行接口）是一种接口标准，规定了接口的物理标准，没有规定电缆和使用协议。

接口根据针脚数量不同分为DB25和DB9：

![](https://i-blog.csdnimg.cn/direct/6d1728d932924111a81f8c221a16d3b6.png)

带孔的为**母头**，带针的为**公头**，两者管脚从同一方向看顺序相反，连接时一一对应：

![](https://i-blog.csdnimg.cn/direct/b4a5a395d4bd4ae9b2997ada83f2654c.png)

**RS-232C标准接口主要引脚定义**

（插针序号括号外为DB25脚位，括号内为DB9脚位）

| 插针序号  | 信号名称 | 功能              | 信号方向    |
| ----- | ---- | --------------- | ------- |
| 1     | PGND | 保护接地            |         |
| 2(3)  | TXD  | 发送数据（串行输出）      | DTE→DCE |
| 3(2)  | RXD  | 接收数据（串行输入）      | DTE←DCE |
| 4(7)  | RTS  | 请求发送            | DTE→DCE |
| 5(8)  | CTS  | 允许发送            | DTE←DCE |
| 6(6)  | DSR  | DCE就绪（数据建立就绪）   | DTE←DCE |
| 7(5)  | SGND | 信号接地            |         |
| 8(1)  | DCD  | 载波检测            | DTE←DCE |
| 20(4) | DTR  | DTE就绪（数据终端准备就绪） | DTE→DCE |
| 22(9) | RI   | 振铃指示            | DTE←DCE |

其中串口通信常用的为2/3/5脚（DB9）。

RS-232C电平规定逻辑1为-3V到-15V，逻辑0为3V到15V。51单片机需要通过MAX232芯片将RS232电平与TTL电平进行转换。

### 通信协议

RS232的通信协议通常遵循96-N-8-1格式：9600bps-无校验位-8位传输数据位-使用1为停止位

校验位：解决串口通信因外部干扰导致的传输偏差问题，分为奇校验、偶校验和无校验（零校验）。

停止位：数据包的起始位由逻辑电平0表示，而停止位可以是0.5/1/1.5/2。

### 串口内部结构

![](https://i-blog.csdnimg.cn/direct/888a7bf9e154411996783aef6eb90edb.png)

TXD/RXD：单片机的串口管脚，TXD对应P3.1，RXD对应P3.0。

SBUF：串口数据缓存寄存器，存储发送和接受的数据。

TH1/TL1：定时器1的功能，采用方式2工作，用于产生波特率。

SMOD：特殊寄存器，控制T1溢出率的分频，进而控制T1/R1的采样频率。置零时先二分频再十六分频，置一时直接十六分频。

TI/R1：发送/接收控制器，数据发送/接收完成时产生发送/接收中断。

## 串口相关寄存器

### 串口控制寄存器SCON

| 位        | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- |
| 字节地址：98H | SM0 | SM1 | SM2 | REN | TB8 | RB8 | TI  | RI  |

| SM0 | SM1 | 方式  | 说明             | 波特率（$f_{\mathrm{osc}}$为外部晶振频率）              |
| --- | --- | --- | -------------- | ------------------------------------------- |
| 0   | 0   | 0   | 移位寄存器          | $f_{\mathrm{osc}}/12$                       |
| 0   | 1   | 1   | 10位异步收发器（8位数据） | 可变                                          |
| 1   | 0   | 2   | 11位异步收发器（9位数据） | $f_{\mathrm{osc}}/64$或$f_{\mathrm{osc}}/12$ |
| 1   | 1   | 3   | 11位异步收发器（9位数据） | 可变                                          |

SM2和RB8用于方式2和方式3中多级通信（一台主机通过一条总线向多个设备发送数据）下数据的选择性接收。

SM2控制RB8是否激活。当SM2=0，RB8不激活；当SM2=1，RB8激活。

RB8在激活状态下控制RI是否激活。当RB8=0，收到信息即丢弃；当RB8=1，收到信息存储进SBUF。RB8在非激活状态下，收到信息均可以存储进SBUF。

REN是允许接收位，置一时启动串行口接收数据，置零时禁止接收，通常置一。

TB8和RB8工作在方式2和方式3用来发送数据的第9位，可用于奇偶校验位或多级通信中地址帧和数据帧的标志位。

TI/R1是发送/接收中断标志位，在方式0当串行发送/接收第8位数据结束时或在其他方式串行发送/接收停止位时置一发送中断请求，需要软件清零取消中断申请等待下一次中断。

### 电源控制寄存器PCON

| 位        | 7    | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| -------- | ---- | --- | --- | --- | --- | --- | --- | --- |
| 字节地址：97H | SMOD |     |     |     |     |     |     |     |

PCON只用到最高位，用于控制波特率的分频。

## 串口工作方式

### 方式0

方式0数据由RXD(P3.0)输入或输出，移位脉冲由TXD输出，发送和接收均为8位数据，低位在前高位在后，波特率为$f_{\mathrm{osc}}/12$。

**输出**（图中线条高低表示对应的高低电平）

![](https://i-blog.csdnimg.cn/direct/83cc7b2278464f0a8492a31220f20a06.png)

**输入**

![](https://i-blog.csdnimg.cn/direct/18fedcb635a2409f9c3980bfbf43bc4e.png)

### 方式1

方式1是10位数据的异步通信口，其中起始位为低电平，停止位为高电平。TXD为数据发送引脚，RXD为数据接收引脚。

![](https://i-blog.csdnimg.cn/direct/5ce9cc78bbe14d94ad92d98bbbfb2ee6.png)

**输出**

![](https://i-blog.csdnimg.cn/direct/a6b611eeab534bba9eafcb2685d41f30.png)

发送开始时，存储在输出寄存器中的数据帧以起始位为首从左向右移入TXD引脚并输出，同时输出寄存器左边的空缺补零。当停止位移至输出寄存器右端时，左边其余位全为0，检测电路检测到该条件使控制电路进行最后一次移位，并将TI置一。

**输入**


![](https://i-blog.csdnimg.cn/direct/911984615778466a9f99192b6177ab5d.png)

位采样脉冲为波特率，由TH1和TL1提供，控制对RXD的电平采样。采样接收到下降沿时起始位有效，开始接收一帧数据，数据帧以起始位为首从右向左移入移位寄存器。起始位移至移位寄存器左端时，控制电路进行最后一次移位。当RI=0且SM2=0时，移位寄存器将接收到9位数据的前8位存储进SBUF，第9位进入RB8并将RI置一。

### 方式2和方式3

方式2和方式3与方式1的不同在于数据帧为11位，多出一位RB8/TB8。其数据帧的接收和发送过程与方式1类似，区别在于在接收数据时，进入RB8的信号从停止位变为了数据位的第9位，可以控制多级通信中信息的选择性发送和接收（当RI=0且SM2=0时）。


![](https://i-blog.csdnimg.cn/direct/45adaf86ade143138018b5c4954cbc17.png)

**输出**（过程与方式1类似）

![](https://i-blog.csdnimg.cn/direct/a2276649741641cb8de59475eb4d253e.png)

**输入**

![](https://i-blog.csdnimg.cn/direct/8badf8971e8045198de3139f59910ff7.png)

## 串口的使用方法

### 波特率计算

方式0：$f_{\mathrm{osc}}/12$

方式2：$(2^{\mathrm{SMOD}}/64)\cdot f_{\mathrm{osc}}$

方式1/3：$(2^{\mathrm{SMOD}}/32)\cdot\mathrm{T1}溢出率$

$2^{\mathrm{SMOD}}$的意义是当SMOD=0/1，进行/不进行二分频。

$\mathrm{T1}溢出率=f_{\mathrm{osc}}/[12\times(256-\mathrm{TH1})]$

其中$12/f_{\mathrm{osc}}$是一个机器周期，$256-\mathrm{TH1}$为定时器在自动重载模式下溢出一次所需的机器周期数（参见外部中断实验中定时器中断部分），两者相乘取倒数得到溢出率。

### 串口初始化步骤

①确定T1工作方式（TMOD寄存器）；

②确定串口工作方式（SCON寄存器）；

③计算TI初值（设定波特率），装载TH1、TL1；

④启动T1（TCON中的TR1位）；

⑤若使用中断，需开启串口中断控制位（IE寄存器）。

```c
//串口初始化函数
void uart_init(u8 baud)
{
	//设置定时器工作方式2，或运算不干扰其他位
	TMOD |= 0X20;
	//设置串口工作方式1
	SCON = 0X50;
	//不采用二分频
	PCON = 0X80;
	//定时器初值设置
	TH1 = baud;
	TL1 = baud;
	//打开接收中断
	ES = 1;
	//打开总中断
	EA = 1;
	//打开定时器
	TR1 = 1;
}
```

# 硬件设计

![](https://i-blog.csdnimg.cn/direct/74f013903a4e442a89c0a6d232bd7e29.png)

该电路未采用MAX232电平转换芯片，而是USB转TTL的CH340G转换芯片，现今笔记本电脑大多没有RS232接口，因此通过USB串口互转实现串口通信。其原理与下载电路相同，单片机程序烧录的过程实质上也是串口通信。

# 实验13 串口通信

实现功能：当串口助手发送数据给单片机，单片机原封不动转发给串口助手显示。

使用波特率计算器获取十六进制初值：

![](https://i-blog.csdnimg.cn/direct/dcd884add53e4600849529a7bb1cb0af.png)

```c
#include "reg52.h"

typedef unsigned char u8;
typedef unsigned int u16;
//串口初始化函数
void uart_init(u8 baud)
{
	TMOD |= 0X20;
	SCON = 0X50;
	PCON = 0X80;
	TH1 = baud;
	TL1 = baud;
	ES = 1;
	EA = 1;
	TR1 = 1;
}

void main()
{
	//串口初始化
	uart_init(0XFA);
	while(1)
	{
	}
}
//处理接收中断(RI=1)的服务函数，串口中断代号为4
void uart() interrupt 4
{
	//定义接收数据的变量
	u8 rec_data = 0;
	//将接收控制器置零
	RI = 0;
	//读取SBUF接收的数据
	rec_data = SBUF;
	//将数据写入SBUF进行发送
	SBUF = rec_data;
	//等待发送中断(TI=1)
	while(!TI);
	//将发送控制器置零
	TI = 0;
}
```

先烧录程序，然后打开串口助手软件：

![](https://i-blog.csdnimg.cn/direct/81962cbab55d466fbcafeb5ec1e51254.png)

连接开发板，检查端口号是否匹配，波特率设为实验所用波特率，在串口设置中检验校验方式，最后打开串口。

输入数据后发送，上方窗口最新行显示接收到的数据：

![](https://i-blog.csdnimg.cn/direct/3f8f82ba07a84d9692dc5cee3c2ff7f7.png)

